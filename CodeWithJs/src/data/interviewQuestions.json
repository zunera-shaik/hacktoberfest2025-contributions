[
  {
    "id": "interview-1",
    "question": "Implement debounce and throttle functions",
    "answer": "**Debounce** delays function execution until after a specified time has passed since the last invocation. **Throttle** limits function execution to once per specified time interval.\n\n**Debounce Implementation:**\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  \n  return function(...args) {\n    // Clear the previous timeout\n    clearTimeout(timeoutId);\n    \n    // Set a new timeout\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\n// Usage example\nconst searchInput = document.getElementById('search');\nconst handleSearch = debounce((event) => {\n  console.log('Searching for:', event.target.value);\n  // API call here\n}, 500);\n\nsearchInput.addEventListener('input', handleSearch);\n```\n\n**Advanced Debounce with Immediate Option:**\n```javascript\nfunction debounce(func, delay, immediate = false) {\n  let timeoutId;\n  \n  return function(...args) {\n    const callNow = immediate && !timeoutId;\n    \n    clearTimeout(timeoutId);\n    \n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      if (!immediate) func.apply(this, args);\n    }, delay);\n    \n    if (callNow) func.apply(this, args);\n  };\n}\n```\n\n**Throttle Implementation:**\n```javascript\nfunction throttle(func, limit) {\n  let inThrottle;\n  \n  return function(...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      \n      setTimeout(() => {\n        inThrottle = false;\n      }, limit);\n    }\n  };\n}\n\n// Usage example\nconst handleScroll = throttle(() => {\n  console.log('Scroll event triggered');\n  // Update scroll position, lazy load images, etc.\n}, 100);\n\nwindow.addEventListener('scroll', handleScroll);\n```\n\n**Advanced Throttle with Leading and Trailing Options:**\n```javascript\nfunction throttle(func, limit, options = {}) {\n  let timeout;\n  let previous = 0;\n  const { leading = true, trailing = true } = options;\n  \n  return function(...args) {\n    const now = Date.now();\n    \n    if (!previous && !leading) {\n      previous = now;\n    }\n    \n    const remaining = limit - (now - previous);\n    \n    if (remaining <= 0 || remaining > limit) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      \n      previous = now;\n      func.apply(this, args);\n    } else if (!timeout && trailing) {\n      timeout = setTimeout(() => {\n        previous = !leading ? 0 : Date.now();\n        timeout = null;\n        func.apply(this, args);\n      }, remaining);\n    }\n  };\n}\n```\n\n**Practical Examples:**\n\n**Search with Debounce:**\n```javascript\nclass SearchComponent {\n  constructor() {\n    this.searchInput = document.getElementById('search');\n    this.resultsContainer = document.getElementById('results');\n    \n    // Debounce search to avoid excessive API calls\n    this.debouncedSearch = debounce(this.performSearch.bind(this), 300);\n    \n    this.searchInput.addEventListener('input', this.debouncedSearch);\n  }\n  \n  async performSearch(event) {\n    const query = event.target.value.trim();\n    \n    if (query.length < 2) {\n      this.resultsContainer.innerHTML = '';\n      return;\n    }\n    \n    try {\n      const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);\n      const results = await response.json();\n      this.displayResults(results);\n    } catch (error) {\n      console.error('Search failed:', error);\n    }\n  }\n  \n  displayResults(results) {\n    this.resultsContainer.innerHTML = results\n      .map(result => `<div class=\"result\">${result.title}</div>`)\n      .join('');\n  }\n}\n```\n\n**Infinite Scroll with Throttle:**\n```javascript\nclass InfiniteScroll {\n  constructor() {\n    this.page = 1;\n    this.loading = false;\n    this.hasMore = true;\n    \n    // Throttle scroll events for better performance\n    this.throttledScroll = throttle(this.handleScroll.bind(this), 200);\n    \n    window.addEventListener('scroll', this.throttledScroll);\n  }\n  \n  handleScroll() {\n    if (this.loading || !this.hasMore) return;\n    \n    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;\n    \n    // Load more content when user is 100px from bottom\n    if (scrollTop + clientHeight >= scrollHeight - 100) {\n      this.loadMoreContent();\n    }\n  }\n  \n  async loadMoreContent() {\n    this.loading = true;\n    \n    try {\n      const response = await fetch(`/api/content?page=${this.page}`);\n      const data = await response.json();\n      \n      if (data.items.length === 0) {\n        this.hasMore = false;\n      } else {\n        this.appendContent(data.items);\n        this.page++;\n      }\n    } catch (error) {\n      console.error('Failed to load content:', error);\n    } finally {\n      this.loading = false;\n    }\n  }\n  \n  appendContent(items) {\n    const container = document.getElementById('content-container');\n    const html = items\n      .map(item => `<div class=\"item\">${item.title}</div>`)\n      .join('');\n    container.insertAdjacentHTML('beforeend', html);\n  }\n}\n```\n\n**Key Differences:**\n- **Debounce**: Waits for silence, then executes once (good for search, input validation)\n- **Throttle**: Executes at most once per interval (good for scroll, resize events)\n\n**Performance Benefits:**\n- Reduces API calls and DOM manipulations\n- Improves user experience by preventing lag\n- Conserves computational resources\n- Better network usage"
  },
  {
    "id": "interview-2",
    "question": "Implement deep clone function for objects",
    "answer": "**Problem:** Create a function that creates a deep copy of an object, including nested objects, arrays, and handling circular references.\n\n**Basic Deep Clone:**\n```javascript\nfunction deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  if (obj instanceof Date) {\n    return new Date(obj.getTime());\n  }\n  \n  if (obj instanceof Array) {\n    return obj.map(item => deepClone(item));\n  }\n  \n  if (typeof obj === 'object') {\n    const cloned = {};\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cloned[key] = deepClone(obj[key]);\n      }\n    }\n    return cloned;\n  }\n}\n\n// Usage\nconst original = {\n  name: 'John',\n  age: 30,\n  address: {\n    city: 'New York',\n    zipCode: '10001'\n  },\n  hobbies: ['reading', 'swimming']\n};\n\nconst cloned = deepClone(original);\ncloned.address.city = 'Boston';\nconsole.log(original.address.city); // 'New York' (unchanged)\nconsole.log(cloned.address.city);   // 'Boston'\n```\n\n**Advanced Deep Clone with Circular Reference Handling:**\n```javascript\nfunction deepClone(obj, visited = new WeakMap()) {\n  // Handle primitives and null\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Handle circular references\n  if (visited.has(obj)) {\n    return visited.get(obj);\n  }\n  \n  // Handle Date objects\n  if (obj instanceof Date) {\n    return new Date(obj.getTime());\n  }\n  \n  // Handle RegExp objects\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags);\n  }\n  \n  // Handle Arrays\n  if (obj instanceof Array) {\n    const cloned = [];\n    visited.set(obj, cloned);\n    \n    for (let i = 0; i < obj.length; i++) {\n      cloned[i] = deepClone(obj[i], visited);\n    }\n    \n    return cloned;\n  }\n  \n  // Handle Objects\n  if (obj instanceof Object) {\n    const cloned = {};\n    visited.set(obj, cloned);\n    \n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cloned[key] = deepClone(obj[key], visited);\n      }\n    }\n    \n    return cloned;\n  }\n}\n\n// Test circular reference\nconst objWithCircular = { name: 'test' };\nobjWithCircular.self = objWithCircular;\n\nconst clonedCircular = deepClone(objWithCircular);\nconsole.log(clonedCircular.self === clonedCircular); // true\nconsole.log(clonedCircular === objWithCircular);     // false\n```\n\n**Comprehensive Deep Clone with Multiple Data Types:**\n```javascript\nfunction deepClone(obj, visited = new WeakMap()) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  if (visited.has(obj)) {\n    return visited.get(obj);\n  }\n  \n  let cloned;\n  \n  if (obj instanceof Date) {\n    cloned = new Date(obj.getTime());\n  } else if (obj instanceof RegExp) {\n    cloned = new RegExp(obj.source, obj.flags);\n  } else if (obj instanceof Map) {\n    cloned = new Map();\n    visited.set(obj, cloned);\n    for (let [key, value] of obj) {\n      cloned.set(deepClone(key, visited), deepClone(value, visited));\n    }\n  } else if (obj instanceof Set) {\n    cloned = new Set();\n    visited.set(obj, cloned);\n    for (let value of obj) {\n      cloned.add(deepClone(value, visited));\n    }\n  } else if (obj instanceof Array) {\n    cloned = [];\n    visited.set(obj, cloned);\n    for (let i = 0; i < obj.length; i++) {\n      cloned[i] = deepClone(obj[i], visited);\n    }\n  } else if (obj instanceof Object) {\n    cloned = {};\n    visited.set(obj, cloned);\n    \n    // Handle both enumerable and non-enumerable properties\n    const keys = Object.getOwnPropertyNames(obj);\n    for (let key of keys) {\n      const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n      if (descriptor.value !== undefined) {\n        cloned[key] = deepClone(descriptor.value, visited);\n      } else {\n        Object.defineProperty(cloned, key, descriptor);\n      }\n    }\n  }\n  \n  return cloned;\n}\n```\n\n**Using JSON Methods (Limited Approach):**\n```javascript\nfunction jsonDeepClone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n// Limitations:\n// - Doesn't handle functions, undefined, Symbol, Date objects properly\n// - Doesn't handle circular references (throws error)\n// - Loses prototype chain\n\n// Example of limitations:\nconst problematic = {\n  func: () => console.log('hello'),\n  date: new Date(),\n  undef: undefined,\n  symbol: Symbol('test')\n};\n\nconsole.log(jsonDeepClone(problematic));\n// { date: \"2023-12-07T10:30:00.000Z\" }\n// func, undef, and symbol are lost\n```\n\n**Lodash-style Deep Clone:**\n```javascript\nfunction cloneDeep(obj) {\n  const getType = (obj) => Object.prototype.toString.call(obj).slice(8, -1);\n  \n  const clone = (obj, visited = new WeakMap()) => {\n    if (obj === null || typeof obj !== 'object') return obj;\n    if (visited.has(obj)) return visited.get(obj);\n    \n    const type = getType(obj);\n    let cloned;\n    \n    switch (type) {\n      case 'Date':\n        cloned = new Date(obj.getTime());\n        break;\n      case 'RegExp':\n        cloned = new RegExp(obj);\n        break;\n      case 'Array':\n        cloned = [];\n        visited.set(obj, cloned);\n        obj.forEach((item, index) => {\n          cloned[index] = clone(item, visited);\n        });\n        break;\n      case 'Object':\n        cloned = {};\n        visited.set(obj, cloned);\n        Object.keys(obj).forEach(key => {\n          cloned[key] = clone(obj[key], visited);\n        });\n        break;\n      case 'Map':\n        cloned = new Map();\n        visited.set(obj, cloned);\n        obj.forEach((value, key) => {\n          cloned.set(clone(key, visited), clone(value, visited));\n        });\n        break;\n      case 'Set':\n        cloned = new Set();\n        visited.set(obj, cloned);\n        obj.forEach(value => {\n          cloned.add(clone(value, visited));\n        });\n        break;\n      default:\n        cloned = obj;\n    }\n    \n    return cloned;\n  };\n  \n  return clone(obj);\n}\n```\n\n**Performance-Optimized Version:**\n```javascript\nfunction fastDeepClone(obj, cache = new WeakMap()) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (cache.has(obj)) return cache.get(obj);\n  \n  const isArray = Array.isArray(obj);\n  const cloned = isArray ? [] : {};\n  cache.set(obj, cloned);\n  \n  const keys = isArray ? obj : Object.keys(obj);\n  const length = keys.length;\n  \n  for (let i = 0; i < length; i++) {\n    const key = isArray ? i : keys[i];\n    const value = obj[key];\n    cloned[key] = (typeof value === 'object' && value !== null) \n      ? fastDeepClone(value, cache) \n      : value;\n  }\n  \n  return cloned;\n}\n```\n\n**Testing Deep Clone Functions:**\n```javascript\n// Test cases\nconst testCases = {\n  simple: { a: 1, b: 2 },\n  nested: { a: { b: { c: 1 } } },\n  array: [1, [2, [3, 4]]],\n  mixed: { a: [1, { b: 2 }], c: { d: [3, 4] } },\n  date: { created: new Date() },\n  regex: { pattern: /test/gi }\n};\n\n// Test circular reference\nconst circular = { a: 1 };\ncircular.self = circular;\n\nObject.entries(testCases).forEach(([name, obj]) => {\n  const cloned = deepClone(obj);\n  console.log(`${name}:`, JSON.stringify(cloned) === JSON.stringify(obj));\n});\n\nconst circularCloned = deepClone(circular);\nconsole.log('Circular handled:', circularCloned.self === circularCloned);\n```\n\n**Key Considerations:**\n- Handle primitive types\n- Handle special objects (Date, RegExp, etc.)\n- Prevent infinite recursion with circular references\n- Maintain object prototype chains if needed\n- Consider performance for large objects\n- Handle edge cases (null, undefined, functions)"
  },
  {
    "id": "interview-3",
    "question": "Implement a function to flatten a nested array",
    "answer": "**Problem:** Convert a nested array of any depth into a single-level array.\n\n**Method 1: Using Built-in flat() (ES2019):**\n```javascript\n// Flatten one level\nconst arr1 = [1, [2, 3], 4];\nconsole.log(arr1.flat()); // [1, 2, 3, 4]\n\n// Flatten multiple levels\nconst arr2 = [1, [2, [3, [4, 5]]]];\nconsole.log(arr2.flat(2)); // [1, 2, 3, [4, 5]]\n\n// Flatten all levels\nconsole.log(arr2.flat(Infinity)); // [1, 2, 3, 4, 5]\n```\n\n**Method 2: Recursive Approach:**\n```javascript\nfunction flattenArray(arr) {\n  const result = [];\n  \n  for (let i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      result.push(...flattenArray(arr[i]));\n    } else {\n      result.push(arr[i]);\n    }\n  }\n  \n  return result;\n}\n\n// Usage\nconst nested = [1, [2, 3], [4, [5, 6, [7, 8]]], 9];\nconsole.log(flattenArray(nested)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n**Method 3: Using reduce():**\n```javascript\nfunction flattenArray(arr) {\n  return arr.reduce((acc, val) => {\n    return acc.concat(Array.isArray(val) ? flattenArray(val) : val);\n  }, []);\n}\n\n// Alternative with spread operator\nfunction flattenArray(arr) {\n  return arr.reduce((acc, val) => \n    Array.isArray(val) ? [...acc, ...flattenArray(val)] : [...acc, val], []\n  );\n}\n```\n\n**Method 4: Iterative Approach with Stack:**\n```javascript\nfunction flattenArray(arr) {\n  const stack = [...arr];\n  const result = [];\n  \n  while (stack.length > 0) {\n    const next = stack.pop();\n    \n    if (Array.isArray(next)) {\n      stack.push(...next);\n    } else {\n      result.push(next);\n    }\n  }\n  \n  return result.reverse();\n}\n```\n\n**Method 5: Using Generator Function:**\n```javascript\nfunction* flattenGenerator(arr) {\n  for (let item of arr) {\n    if (Array.isArray(item)) {\n      yield* flattenGenerator(item);\n    } else {\n      yield item;\n    }\n  }\n}\n\nfunction flattenArray(arr) {\n  return [...flattenGenerator(arr)];\n}\n\n// Usage\nconst nested = [1, [2, [3, 4]], 5];\nconsole.log(flattenArray(nested)); // [1, 2, 3, 4, 5]\n```\n\n**Method 6: Flatten with Depth Control:**\n```javascript\nfunction flattenArray(arr, depth = Infinity) {\n  if (depth === 0) return arr.slice();\n  \n  return arr.reduce((acc, val) => {\n    if (Array.isArray(val) && depth > 0) {\n      acc.push(...flattenArray(val, depth - 1));\n    } else {\n      acc.push(val);\n    }\n    return acc;\n  }, []);\n}\n\n// Usage\nconst nested = [1, [2, [3, [4, 5]]]];\nconsole.log(flattenArray(nested, 1)); // [1, 2, [3, [4, 5]]]\nconsole.log(flattenArray(nested, 2)); // [1, 2, 3, [4, 5]]\nconsole.log(flattenArray(nested));    // [1, 2, 3, 4, 5] (all levels)\n```\n\n**Method 7: Using toString() and split() (Numbers only):**\n```javascript\nfunction flattenNumbers(arr) {\n  return arr.toString().split(',').map(Number);\n}\n\n// Only works with numbers\nconst numbers = [1, [2, 3], [4, [5, 6]]];\nconsole.log(flattenNumbers(numbers)); // [1, 2, 3, 4, 5, 6]\n\n// Won't work properly with strings or other types\n```\n\n**Method 8: Using JSON methods (Limited):**\n```javascript\nfunction flattenArray(arr) {\n  const str = JSON.stringify(arr);\n  const flattened = str.replace(/\\[|\\]/g, '').split(',');\n  return flattened.map(item => {\n    const parsed = JSON.parse(item);\n    return parsed;\n  });\n}\n\n// Limited to JSON-serializable values\n```\n\n**Advanced: Flatten Objects and Arrays:**\n```javascript\nfunction flattenMixed(arr, depth = Infinity) {\n  const result = [];\n  \n  function flatten(item, currentDepth) {\n    if (currentDepth === 0) {\n      result.push(item);\n      return;\n    }\n    \n    if (Array.isArray(item)) {\n      for (let element of item) {\n        flatten(element, currentDepth - 1);\n      }\n    } else if (typeof item === 'object' && item !== null) {\n      for (let key in item) {\n        if (item.hasOwnProperty(key)) {\n          flatten(item[key], currentDepth - 1);\n        }\n      }\n    } else {\n      result.push(item);\n    }\n  }\n  \n  flatten(arr, depth);\n  return result;\n}\n\n// Usage\nconst mixed = [1, { a: 2, b: [3, 4] }, [5, { c: 6 }]];\nconsole.log(flattenMixed(mixed)); // [1, 2, 3, 4, 5, 6]\n```\n\n**Performance Comparison Function:**\n```javascript\nfunction performanceTest() {\n  const createNestedArray = (depth) => {\n    let arr = [1, 2, 3];\n    for (let i = 0; i < depth; i++) {\n      arr = [arr, [arr], [[arr]]];\n    }\n    return arr;\n  };\n  \n  const testArray = createNestedArray(5);\n  \n  const methods = {\n    'Native flat()': () => testArray.flat(Infinity),\n    'Recursive': () => flattenRecursive(testArray),\n    'Reduce': () => flattenReduce(testArray),\n    'Iterative': () => flattenIterative(testArray),\n    'Generator': () => flattenGenerator(testArray)\n  };\n  \n  Object.entries(methods).forEach(([name, method]) => {\n    const start = performance.now();\n    const result = method();\n    const end = performance.now();\n    console.log(`${name}: ${end - start}ms, length: ${result.length}`);\n  });\n}\n\n// Run performance test\n// performanceTest();\n```\n\n**Edge Cases Handling:**\n```javascript\nfunction robustFlatten(arr) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('Input must be an array');\n  }\n  \n  const result = [];\n  \n  function flatten(item) {\n    if (Array.isArray(item)) {\n      for (let i = 0; i < item.length; i++) {\n        flatten(item[i]);\n      }\n    } else {\n      // Handle sparse arrays (empty slots)\n      result.push(item);\n    }\n  }\n  \n  flatten(arr);\n  return result;\n}\n\n// Test edge cases\nconsole.log(robustFlatten([1, , 3, [4, , 6]])); // [1, undefined, 3, 4, undefined, 6]\nconsole.log(robustFlatten([])); // []\nconsole.log(robustFlatten([null, undefined, 0, false, ''])); // [null, undefined, 0, false, '']\n```\n\n**TypeScript Version:**\n```typescript\nfunction flattenArray<T>(arr: (T | T[])[]): T[] {\n  const result: T[] = [];\n  \n  for (const item of arr) {\n    if (Array.isArray(item)) {\n      result.push(...flattenArray(item));\n    } else {\n      result.push(item);\n    }\n  }\n  \n  return result;\n}\n\n// Usage with type safety\nconst numbers: (number | number[])[] = [1, [2, 3], [4, [5, 6]]];\nconst flattened: number[] = flattenArray(numbers);\n```\n\n**Key Points:**\n- Native `flat()` is usually the most efficient\n- Recursive approaches are clean but can cause stack overflow on very deep arrays\n- Iterative approaches avoid stack overflow\n- Consider the data types and depth requirements\n- Handle edge cases like sparse arrays and non-array inputs"
  },
  {
    "id": "interview-4",
    "question": "Implement a Promise.all() polyfill",
    "answer": "**Problem:** Implement a polyfill for Promise.all() that takes an array of promises and returns a single promise that resolves when all input promises resolve, or rejects when any input promise rejects.\n\n**Basic Promise.all() Polyfill:**\n```javascript\nfunction promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    // Handle empty array\n    if (promises.length === 0) {\n      resolve([]);\n      return;\n    }\n    \n    const results = [];\n    let completedPromises = 0;\n    \n    promises.forEach((promise, index) => {\n      // Ensure we're working with a promise\n      Promise.resolve(promise)\n        .then(value => {\n          results[index] = value;\n          completedPromises += 1;\n          \n          // All promises completed\n          if (completedPromises === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  });\n}\n\n// Usage\nconst promise1 = Promise.resolve(1);\nconst promise2 = Promise.resolve(2);\nconst promise3 = Promise.resolve(3);\n\npromiseAll([promise1, promise2, promise3])\n  .then(results => console.log(results)) // [1, 2, 3]\n  .catch(error => console.error(error));\n```\n\n**Enhanced Version with Better Error Handling:**\n```javascript\nfunction promiseAll(iterable) {\n  return new Promise((resolve, reject) => {\n    // Convert iterable to array\n    const promises = Array.from(iterable);\n    \n    // Handle empty array\n    if (promises.length === 0) {\n      resolve([]);\n      return;\n    }\n    \n    const results = new Array(promises.length);\n    let settledCount = 0;\n    let hasRejected = false;\n    \n    promises.forEach((promise, index) => {\n      Promise.resolve(promise)\n        .then(value => {\n          if (hasRejected) return; // Don't process if already rejected\n          \n          results[index] = value;\n          settledCount++;\n          \n          if (settledCount === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch(reason => {\n          if (hasRejected) return; // Don't reject multiple times\n          \n          hasRejected = true;\n          reject(reason);\n        });\n    });\n  });\n}\n```\n\n**Complete Polyfill with Edge Cases:**\n```javascript\nif (!Promise.all) {\n  Promise.all = function(iterable) {\n    return new Promise((resolve, reject) => {\n      // Handle non-iterable input\n      if (iterable == null || typeof iterable[Symbol.iterator] !== 'function') {\n        reject(new TypeError('Promise.all accepts an iterable'));\n        return;\n      }\n      \n      const promises = Array.from(iterable);\n      \n      // Handle empty iterable\n      if (promises.length === 0) {\n        resolve([]);\n        return;\n      }\n      \n      const results = new Array(promises.length);\n      let resolvedCount = 0;\n      let rejected = false;\n      \n      promises.forEach((promise, index) => {\n        // Handle thenable objects and non-promises\n        Promise.resolve(promise)\n          .then(value => {\n            if (rejected) return;\n            \n            results[index] = value;\n            resolvedCount++;\n            \n            if (resolvedCount === promises.length) {\n              resolve(results);\n            }\n          })\n          .catch(reason => {\n            if (rejected) return;\n            \n            rejected = true;\n            reject(reason);\n          });\n      });\n    });\n  };\n}\n```\n\n**Advanced Implementation with Non-Promise Values:**\n```javascript\nfunction promiseAll(iterable) {\n  return new Promise((resolve, reject) => {\n    try {\n      const array = Array.from(iterable);\n      const length = array.length;\n      \n      if (length === 0) {\n        resolve([]);\n        return;\n      }\n      \n      const results = new Array(length);\n      let remaining = length;\n      \n      array.forEach((item, index) => {\n        // Handle both promises and non-promise values\n        if (item && typeof item.then === 'function') {\n          // It's a thenable\n          item.then(\n            value => {\n              results[index] = value;\n              remaining--;\n              if (remaining === 0) {\n                resolve(results);\n              }\n            },\n            reason => reject(reason)\n          );\n        } else {\n          // It's not a promise, resolve immediately\n          results[index] = item;\n          remaining--;\n          if (remaining === 0) {\n            resolve(results);\n          }\n        }\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n```\n\n**Implementation with Async/Await:**\n```javascript\nasync function promiseAll(promises) {\n  const results = [];\n  const errors = [];\n  \n  try {\n    for (let i = 0; i < promises.length; i++) {\n      try {\n        results[i] = await promises[i];\n      } catch (error) {\n        throw error; // First rejection stops everything\n      }\n    }\n    return results;\n  } catch (error) {\n    throw error;\n  }\n}\n\n// Note: This sequential approach doesn't match Promise.all's concurrent behavior\n// Better concurrent version:\nasync function promiseAllConcurrent(promises) {\n  const results = await Promise.all(\n    promises.map(async (promise, index) => {\n      try {\n        return await promise;\n      } catch (error) {\n        throw { index, error };\n      }\n    })\n  );\n  return results;\n}\n```\n\n**Testing the Implementation:**\n```javascript\n// Test cases\nfunction runTests() {\n  console.log('Testing Promise.all polyfill...');\n  \n  // Test 1: All promises resolve\n  const test1 = promiseAll([\n    Promise.resolve(1),\n    Promise.resolve(2),\n    Promise.resolve(3)\n  ]);\n  \n  test1.then(results => {\n    console.log('Test 1 passed:', JSON.stringify(results) === JSON.stringify([1, 2, 3]));\n  });\n  \n  // Test 2: One promise rejects\n  const test2 = promiseAll([\n    Promise.resolve(1),\n    Promise.reject('Error'),\n    Promise.resolve(3)\n  ]);\n  \n  test2.catch(error => {\n    console.log('Test 2 passed:', error === 'Error');\n  });\n  \n  // Test 3: Empty array\n  const test3 = promiseAll([]);\n  \n  test3.then(results => {\n    console.log('Test 3 passed:', Array.isArray(results) && results.length === 0);\n  });\n  \n  // Test 4: Non-promise values\n  const test4 = promiseAll([1, 2, Promise.resolve(3)]);\n  \n  test4.then(results => {\n    console.log('Test 4 passed:', JSON.stringify(results) === JSON.stringify([1, 2, 3]));\n  });\n  \n  // Test 5: Delayed promises\n  const test5 = promiseAll([\n    new Promise(resolve => setTimeout(() => resolve('slow'), 100)),\n    Promise.resolve('fast')\n  ]);\n  \n  test5.then(results => {\n    console.log('Test 5 passed:', JSON.stringify(results) === JSON.stringify(['slow', 'fast']));\n  });\n}\n\n// runTests();\n```\n\n**Comparison with Native Promise.all:**\n```javascript\nfunction compareImplementations() {\n  const promises = [\n    Promise.resolve(1),\n    new Promise(resolve => setTimeout(() => resolve(2), 50)),\n    Promise.resolve(3)\n  ];\n  \n  console.time('Native Promise.all');\n  Promise.all(promises).then(results => {\n    console.timeEnd('Native Promise.all');\n    console.log('Native results:', results);\n  });\n  \n  console.time('Custom promiseAll');\n  promiseAll(promises).then(results => {\n    console.timeEnd('Custom promiseAll');\n    console.log('Custom results:', results);\n  });\n}\n\n// compareImplementations();\n```\n\n**Related Promise Utilities:**\n```javascript\n// Promise.allSettled polyfill\nfunction promiseAllSettled(promises) {\n  return Promise.all(\n    promises.map(promise =>\n      Promise.resolve(promise)\n        .then(value => ({ status: 'fulfilled', value }))\n        .catch(reason => ({ status: 'rejected', reason }))\n    )\n  );\n}\n\n// Promise.race polyfill\nfunction promiseRace(promises) {\n  return new Promise((resolve, reject) => {\n    if (promises.length === 0) {\n      return; // Never settles\n    }\n    \n    promises.forEach(promise => {\n      Promise.resolve(promise)\n        .then(resolve, reject);\n    });\n  });\n}\n\n// Promise.any polyfill (ES2021)\nfunction promiseAny(promises) {\n  return new Promise((resolve, reject) => {\n    if (promises.length === 0) {\n      reject(new AggregateError([], 'All promises were rejected'));\n      return;\n    }\n    \n    let rejectionCount = 0;\n    const errors = [];\n    \n    promises.forEach((promise, index) => {\n      Promise.resolve(promise)\n        .then(resolve) // First fulfillment wins\n        .catch(error => {\n          errors[index] = error;\n          rejectionCount++;\n          \n          if (rejectionCount === promises.length) {\n            reject(new AggregateError(errors, 'All promises were rejected'));\n          }\n        });\n    });\n  });\n}\n```\n\n**Key Implementation Points:**\n- Handle empty arrays correctly\n- Preserve order of results\n- Fail fast on first rejection\n- Convert non-promises using Promise.resolve()\n- Handle iterables, not just arrays\n- Avoid memory leaks by checking rejection state\n- Match native behavior exactly"
  },
  {
    "id": "interview-5",
    "question": "Create a memoization function for expensive operations",
    "answer": "**Problem:** Implement a memoization function that caches the results of expensive function calls and returns the cached result when the same inputs occur again.\n\n**Basic Memoization:**\n```javascript\nfunction memoize(fn) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      console.log('Cache hit for:', args);\n      return cache.get(key);\n    }\n    \n    console.log('Computing result for:', args);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    \n    return result;\n  };\n}\n\n// Usage example\nfunction expensiveFunction(n) {\n  // Simulate expensive operation\n  let result = 0;\n  for (let i = 0; i < n * 1000000; i++) {\n    result += i;\n  }\n  return result;\n}\n\nconst memoizedExpensive = memoize(expensiveFunction);\n\nconsole.log(memoizedExpensive(100)); // Computed\nconsole.log(memoizedExpensive(100)); // Cached\nconsole.log(memoizedExpensive(200)); // Computed\nconsole.log(memoizedExpensive(100)); // Cached\n```\n\n**Advanced Memoization with Custom Key Generator:**\n```javascript\nfunction memoize(fn, getKey = (...args) => JSON.stringify(args)) {\n  const cache = new Map();\n  \n  const memoized = function(...args) {\n    const key = getKey(...args);\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    \n    return result;\n  };\n  \n  // Add cache management methods\n  memoized.cache = cache;\n  memoized.clear = () => cache.clear();\n  memoized.delete = (key) => cache.delete(key);\n  memoized.has = (key) => cache.has(key);\n  \n  return memoized;\n}\n\n// Custom key generator for objects\nfunction objectKeyGenerator(obj) {\n  return Object.keys(obj)\n    .sort()\n    .map(key => `${key}:${obj[key]}`)\n    .join('|');\n}\n\nconst memoizedWithCustomKey = memoize(\n  (user) => `Hello, ${user.name}!`,\n  objectKeyGenerator\n);\n```\n\n**Memoization with TTL (Time To Live):**\n```javascript\nfunction memoizeWithTTL(fn, ttl = 60000) { // Default 1 minute\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    const now = Date.now();\n    \n    if (cache.has(key)) {\n      const { result, timestamp } = cache.get(key);\n      \n      if (now - timestamp < ttl) {\n        console.log('Cache hit (fresh):', args);\n        return result;\n      } else {\n        console.log('Cache expired, removing:', args);\n        cache.delete(key);\n      }\n    }\n    \n    console.log('Computing new result:', args);\n    const result = fn.apply(this, args);\n    \n    cache.set(key, {\n      result,\n      timestamp: now\n    });\n    \n    return result;\n  };\n}\n\n// Usage\nconst memoizedWithTTL = memoizeWithTTL(\n  (x) => x * x,\n  5000 // 5 seconds TTL\n);\n```\n\n**LRU (Least Recently Used) Memoization:**\n```javascript\nfunction memoizeWithLRU(fn, maxSize = 100) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      // Move to end (mark as recently used)\n      const result = cache.get(key);\n      cache.delete(key);\n      cache.set(key, result);\n      return result;\n    }\n    \n    const result = fn.apply(this, args);\n    \n    // If cache is full, remove least recently used (first item)\n    if (cache.size >= maxSize) {\n      const firstKey = cache.keys().next().value;\n      cache.delete(firstKey);\n    }\n    \n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Test LRU behavior\nconst lruMemoized = memoizeWithLRU((x) => x * x, 3);\n\nlruMemoized(1); // Computed\nlruMemoized(2); // Computed\nlruMemoized(3); // Computed\nlruMemoized(4); // Computed, evicts 1\nlruMemoized(1); // Computed again (was evicted)\n```\n\n**Memoization for Recursive Functions:**\n```javascript\n// Fibonacci without memoization (inefficient)\nfunction fibonacci(n) {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Fibonacci with memoization\nconst memoizedFibonacci = memoize(function fibonacci(n) {\n  if (n <= 1) return n;\n  return memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2);\n});\n\n// Alternative: Built-in memoization\nfunction createMemoizedFibonacci() {\n  const cache = new Map();\n  \n  function fibonacci(n) {\n    if (n <= 1) return n;\n    if (cache.has(n)) return cache.get(n);\n    \n    const result = fibonacci(n - 1) + fibonacci(n - 2);\n    cache.set(n, result);\n    return result;\n  }\n  \n  return fibonacci;\n}\n\nconst betterFibonacci = createMemoizedFibonacci();\n\n// Performance comparison\nconsole.time('Regular fibonacci(40)');\nconsole.log(fibonacci(35)); // Very slow\nconsole.timeEnd('Regular fibonacci(40)');\n\nconsole.time('Memoized fibonacci(40)');\nconsole.log(memoizedFibonacci(35)); // Much faster\nconsole.timeEnd('Memoized fibonacci(40)');\n```\n\n**Async Function Memoization:**\n```javascript\nfunction memoizeAsync(fn) {\n  const cache = new Map();\n  \n  return async function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      const cachedPromise = cache.get(key);\n      console.log('Returning cached promise for:', args);\n      return cachedPromise;\n    }\n    \n    console.log('Creating new promise for:', args);\n    const promise = fn.apply(this, args);\n    \n    // Cache the promise, not just the result\n    cache.set(key, promise);\n    \n    try {\n      const result = await promise;\n      return result;\n    } catch (error) {\n      // Remove failed promises from cache\n      cache.delete(key);\n      throw error;\n    }\n  };\n}\n\n// Usage with async function\nconst fetchUser = memoizeAsync(async (userId) => {\n  console.log(`Fetching user ${userId}...`);\n  const response = await fetch(`/api/users/${userId}`);\n  return response.json();\n});\n\n// Multiple calls will share the same promise\nfetchUser(1).then(user => console.log('User 1:', user));\nfetchUser(1).then(user => console.log('User 1 (cached):', user));\n```\n\n**Decorator Pattern for Memoization:**\n```javascript\nfunction memoized(options = {}) {\n  return function decorator(target, propertyKey, descriptor) {\n    const originalMethod = descriptor.value;\n    const cache = new Map();\n    const { ttl, maxSize, keyGenerator } = options;\n    \n    descriptor.value = function(...args) {\n      const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);\n      const now = Date.now();\n      \n      // Check cache\n      if (cache.has(key)) {\n        const { result, timestamp } = cache.get(key);\n        \n        if (!ttl || now - timestamp < ttl) {\n          return result;\n        } else {\n          cache.delete(key);\n        }\n      }\n      \n      // Execute original method\n      const result = originalMethod.apply(this, args);\n      \n      // Manage cache size\n      if (maxSize && cache.size >= maxSize) {\n        const firstKey = cache.keys().next().value;\n        cache.delete(firstKey);\n      }\n      \n      // Cache result\n      cache.set(key, {\n        result,\n        timestamp: now\n      });\n      \n      return result;\n    };\n    \n    return descriptor;\n  };\n}\n\n// Usage as decorator (requires Babel or TypeScript)\nclass Calculator {\n  @memoized({ ttl: 5000, maxSize: 50 })\n  expensiveCalculation(x, y) {\n    console.log(`Computing ${x} + ${y}`);\n    // Simulate expensive operation\n    let result = 0;\n    for (let i = 0; i < x * y * 1000; i++) {\n      result += i;\n    }\n    return result;\n  }\n}\n```\n\n**WeakMap Memoization (for Object Arguments):**\n```javascript\nfunction memoizeWithWeakMap(fn) {\n  const cache = new WeakMap();\n  \n  return function(obj, ...otherArgs) {\n    if (typeof obj !== 'object' || obj === null) {\n      throw new Error('First argument must be an object');\n    }\n    \n    if (!cache.has(obj)) {\n      cache.set(obj, new Map());\n    }\n    \n    const objCache = cache.get(obj);\n    const key = JSON.stringify(otherArgs);\n    \n    if (objCache.has(key)) {\n      return objCache.get(key);\n    }\n    \n    const result = fn.call(this, obj, ...otherArgs);\n    objCache.set(key, result);\n    \n    return result;\n  };\n}\n\n// Usage\nconst processObject = memoizeWithWeakMap((obj, operation) => {\n  console.log(`Processing object with operation: ${operation}`);\n  return Object.keys(obj).length * operation;\n});\n\nconst myObj = { a: 1, b: 2 };\nconsole.log(processObject(myObj, 'count')); // Computed\nconsole.log(processObject(myObj, 'count')); // Cached\n```\n\n**Complete Memoization Library:**\n```javascript\nclass Memoizer {\n  constructor(options = {}) {\n    this.cache = new Map();\n    this.maxSize = options.maxSize || Infinity;\n    this.ttl = options.ttl || Infinity;\n    this.keyGenerator = options.keyGenerator || JSON.stringify;\n    this.stats = { hits: 0, misses: 0, evictions: 0 };\n  }\n  \n  memoize(fn) {\n    return (...args) => {\n      const key = this.keyGenerator(args);\n      const now = Date.now();\n      \n      // Check for existing cached result\n      if (this.cache.has(key)) {\n        const entry = this.cache.get(key);\n        \n        if (now - entry.timestamp < this.ttl) {\n          this.stats.hits++;\n          // Update access time for LRU\n          entry.lastAccess = now;\n          return entry.result;\n        } else {\n          this.cache.delete(key);\n        }\n      }\n      \n      this.stats.misses++;\n      \n      // Compute result\n      const result = fn.apply(this, args);\n      \n      // Manage cache size\n      if (this.cache.size >= this.maxSize) {\n        this._evictLRU();\n      }\n      \n      // Store result\n      this.cache.set(key, {\n        result,\n        timestamp: now,\n        lastAccess: now\n      });\n      \n      return result;\n    };\n  }\n  \n  _evictLRU() {\n    let oldestKey = null;\n    let oldestTime = Infinity;\n    \n    for (const [key, entry] of this.cache) {\n      if (entry.lastAccess < oldestTime) {\n        oldestTime = entry.lastAccess;\n        oldestKey = key;\n      }\n    }\n    \n    if (oldestKey) {\n      this.cache.delete(oldestKey);\n      this.stats.evictions++;\n    }\n  }\n  \n  clear() {\n    this.cache.clear();\n    this.stats = { hits: 0, misses: 0, evictions: 0 };\n  }\n  \n  getStats() {\n    const total = this.stats.hits + this.stats.misses;\n    return {\n      ...this.stats,\n      hitRate: total > 0 ? this.stats.hits / total : 0,\n      cacheSize: this.cache.size\n    };\n  }\n}\n\n// Usage\nconst memoizer = new Memoizer({\n  maxSize: 100,\n  ttl: 60000, // 1 minute\n  keyGenerator: (args) => args.join('-')\n});\n\nconst expensiveFunction = memoizer.memoize((a, b) => {\n  console.log(`Computing ${a} + ${b}`);\n  return a + b;\n});\n\nconsole.log(expensiveFunction(1, 2)); // Computed\nconsole.log(expensiveFunction(1, 2)); // Cached\nconsole.log(memoizer.getStats()); // { hits: 1, misses: 1, evictions: 0, hitRate: 0.5, cacheSize: 1 }\n```\n\n**Key Benefits of Memoization:**\n- Dramatic performance improvements for repeated calculations\n- Especially useful for recursive algorithms\n- Reduces redundant API calls\n- Can be combined with other optimization techniques\n\n**When to Use Memoization:**\n- Pure functions (same input â†’ same output)\n- Expensive computations\n- Recursive algorithms (Fibonacci, factorial)\n- API calls with repeating parameters\n- Complex data transformations"
  }
]
